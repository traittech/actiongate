// Auto-generated, do not edit
/* eslint-disable */

import { defineMethod } from '@substrate/txwrapper-core';

import type { Args, BaseTxInfo, OptionsWithMeta, UnsignedTransaction } from '@substrate/txwrapper-core';

import type {
  BlockchainGenericAddress,
  BlockchainGenericBalance,
  BlockchainGenericId,
  CTAction,
  CTAtomicActionGeneric,
  NftWitness,
} from '../types/api/common';

import { ActionType } from '../types/api/actions';

{{#each modules}}

{{#each items}}

{{#if documentation.short}}
/**
 * Arguments required to {{{documentation.short}}}
 */
{{/if}}
export interface {{{argsTypeName}}} extends Args {
  {{#each params}}
  {{#if this.description}}
  /**
   * {{{this.description}}}
   */
  {{/if}}
  {{{this.name}}}: {{{this.type}}};
  {{/each}}
};

/**
{{#if documentation.full}}
 * {{{documentation.full}}}
{{/if}}
 * @param args - The arguments of the transaction.
 * @param info - Base transaction information.
 * @param options - Additional options with metadata.
 * @returns An unsigned transaction.
 */
export function {{{functionName}}}(
  args: {{{argsTypeName}}},
  info: BaseTxInfo,
  options: OptionsWithMeta
): UnsignedTransaction {
  return defineMethod(
    {
      method: {
        args,
        name: '{{{methodName}}}',
        pallet: '{{{palletName}}}',
      },
      ...info,
    },
    options
  );
}

export type {{{actionTypeName}}} = CTAtomicActionGeneric<
  ActionType.{{{actionName}}},
  {{{argsTypeName}}}
>;

/*---------------------------------------------------------------------------------- */

{{/each}}
{{/each}}


/**
 * Represents a single action within an atomic operation.
 */
export type CTAtomicAction =
{{#each ctAtomicActions}}
  | {{{this.actionType}}}
{{/each}};

/**
 * Builds clearing transaction action from atomic action.
 * @param action - Atomic action.
 * @param baseTxInfo - Base transaction information.
 * @param options - Additional options including the registry and metadata RPC.
 * @returns An action in clearing transaction.
 */
export function buildCTAction(action: CTAtomicAction, baseTxInfo: BaseTxInfo, options: OptionsWithMeta): CTAction {
  const { actionType, arguments: args } = action;

  let unsigned: UnsignedTransaction;

  // Handle different action types
  switch (actionType) {
  {{#each ctAtomicActions}}
    case ActionType.{{{this.actionName}}}: {
      unsigned = {{{this.method}}}(args, baseTxInfo, options);
      break;
    }
  {{/each}}

    default: {
      if (actionType) {
        throw new Error(`Unsupported action type: ${actionType}`);
      } else {
        throw new Error('CT action has no "actionType"');
      }
    }
  }

  const actionTxType: CTAction = [action.origin, unsigned.method];

  return actionTxType;
}