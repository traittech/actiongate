// Auto-generated, do not edit
/* eslint-disable */

import { z } from 'zod';

import { defineMethod } from '@substrate/txwrapper-core';

import type { Args, BaseTxInfo, OptionsWithMeta, TxInfo, TxMethod, UnsignedTransaction } from '@substrate/txwrapper-core';

import type {
  BlockchainGenericAccount,
  BlockchainGenericBalance,
  BlockchainGenericBoolean,
  BlockchainGenericId,
  BlockchainGenericText,
  CTAtomicActionGeneric,
  CTAtomicActions,
  NftWitness,
} from '../../types/api';

import { ActionType } from '../../types/api/actions';

import * as schema from '../../validator/schemas';

export function constructUnsignedTransaction(
  pallet: string,
  name: string,
  args: Args,
  baseTxInfo: BaseTxInfo,
  options: OptionsWithMeta
): UnsignedTransaction {
  const txMethod: TxMethod = { args, name, pallet };
  const txInfo: TxInfo = { method: txMethod, ...baseTxInfo };

  return defineMethod(txInfo, options);
}

{{#each modules}}

{{#each items}}

{{#if documentation.short}}
/**
 * Arguments required to {{{documentation.short}}}
 */
{{/if}}
export interface {{{actionName}}}Args extends Args {
  {{#each params}}
  {{#if this.description}}
  /**
   * {{{this.description}}}
   */
  {{/if}}
  {{{this.name}}}{{#if this.isOptional}}?{{/if}}: {{{this.type}}};
  {{/each}}
};

const {{{actionName}}}ArgsSchema = z.object({
  {{#each params}}
  {{{this.name}}}: {{#if this.isOptional}}z.optional({{/if}}schema.{{{this.type}}}Schema{{#if this.isOptional}}){{/if}},
  {{/each}}
});

/**
{{#if documentation.full}}
 * {{{documentation.full}}}
{{/if}}
 * @param args - The arguments of the transaction. {@link {{{actionName}}}Args}
 * @param info - Base transaction information. {@link BaseTxInfo}
 * @param options - Additional options with metadata. {@link OptionsWithMeta}
 * @returns An unsigned transaction. {@link UnsignedTransaction}
 */
export function {{{functionName}}}(
  args: {{{actionName}}}Args,
  info: BaseTxInfo,
  options: OptionsWithMeta
): UnsignedTransaction {
  // throws error if validation is failed
  const validArgs = {{{actionName}}}ArgsSchema.parse(args);

  return constructUnsignedTransaction('{{{palletName}}}', '{{{methodName}}}', validArgs, info, options);
}

export type {{{actionName}}}Action = CTAtomicActionGeneric<
  ActionType.{{{actionName}}},
  {{{actionName}}}Args
>;

/*---------------------------------------------------------------------------------- */

{{/each}}
{{/each}}


/**
 * Represents a single action within an atomic operation.
 */
export type CTAtomicAction =
{{#each ctAtomicActions}}
  | {{{this.actionName}}}Action
{{/each}};

/**
 * Represents an action args
 */
export type ActionArgs = CTAtomicAction['arguments'];

/**
 * Builds an unsigned transaction based on the provided `ActionType`.
 *
 * @param actionType - transaction `ActionType`
 * @param args - The arguments for the extrinsic function.
 * @param info - Base transaction information.
 * @param options - Additional options with metadata.
 * @returns An unsigned transaction.
 *
 * @throws If the transaction is unsupported.
 */
export function buildUnsignedTxFromActionType(
  actionType: ActionType,
  args: ActionArgs,
  info: BaseTxInfo,
  options: OptionsWithMeta
): UnsignedTransaction {
  let unsigned: UnsignedTransaction;

  // Handle different action types
  switch (actionType) {
  {{#each ctAtomicActions}}
    case ActionType.{{{this.actionName}}}: {
      unsigned = {{{this.function}}}(args as {{{this.actionName}}}Args, info, options);
      break;
    }
  {{/each}}

    default: {
      throw new Error(`Unsupported transaction type: ${actionType}`);
    }
  }

  return unsigned;
}